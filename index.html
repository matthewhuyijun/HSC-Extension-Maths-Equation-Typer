<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>HSC Ext 2 – Visual Math Printer (Dual Inputs with Vectors)</title>
  <style>
    body{font-family:sans-serif;margin:0;padding:0;background:#f8fafc;color:#111}
    header{padding:10px;background:#2563eb;color:#fff;display:flex;justify-content:space-between;align-items:center}
    #status{font-size:12px;margin-left:10px}
    #preview{padding:10px;min-height:60px;border-bottom:1px solid #ccc;background:#fff}
    #editorWrap{padding:10px}
    .editor{margin-bottom:10px;position:relative}
    .editor label{display:flex;justify-content:flex-start;align-items:center;margin-bottom:4px;gap:8px}
    .editor button.copyBtn{margin-left:0;font-size:11px;padding:2px 8px;}
    math-field, textarea{width:100%;min-height:100px;font-size:20px;padding:8px;border:1px solid #ccc;border-radius:6px;display:block;background:#fff}
    math-field .ML__paren.ML__delim { min-height: 100% !important; }
    math-field .ML__matrix { position: relative; }
    math-field .ML__matrix .ML__delim { height: 100% !important; }
    #keyboard{padding:10px;background:#e2e8f0}
    .tabs{display:flex;gap:6px;margin-bottom:6px;flex-wrap:wrap}
    .tab{padding:6px 10px;border:1px solid #ccc;border-radius:6px;cursor:pointer;background:#fff}
    .tab.active{background:#2563eb;color:#fff}
    .keys{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:8px}
    .key{padding:8px;border:1px solid #ccc;border-radius:10px;cursor:pointer;background:#fff;outline:none;min-height:88px;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;}
    .key mjx-container{font-size:24px; max-width: 100%;}
    .selector{font-size:12px;position:absolute;top:4px;right:4px;z-index:10;}
    #tests{padding:10px;border-top:1px solid #ccc;background:#fff;font:12px/1.4 ui-monospace,Consolas,monospace}
    #tests button{padding:6px 10px;border:1px solid #ccc;border-radius:6px;background:#fff;cursor:pointer}
    #log{white-space:pre-wrap}

    /* Added: Hide MathLive toolbar icons and features */
    math-field::part(virtual-keyboard-toggle) { display: none !important; }
    math-field::part(menu-toggle) { display: none !important; }
    math-field::part(toolbar) { display: none !important; }
  </style>
  <script>
    window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }, svg: { fontCache: 'global' } };
    window.whenMathJaxReady = window.whenMathJaxReady || function(){};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" defer onload="whenMathJaxReady()"></script>
</head>
<body>
  <header>
    <h1>HSC Ext 2 – Visual Math Printer</h1>
    <div id="status">Loading editor…</div>
  </header>

  <div id="preview"></div>

  <div id="editorWrap">
    <div class="editor">
      <label><strong>Rendered Input (Editable – MathLive)</strong></label>
      <math-field id="mf2" smart-fence letter-shape-style="tex" virtual-keyboard-mode="off" remove-extraneous-parentheses="on"></math-field>
    </div>
    <div class="editor">
      <label><strong>Raw LaTeX Input</strong><button id="copyBtn" class="copyBtn">Copy LaTeX</button></label>
      <textarea id="ta" placeholder="Fallback LaTeX input…"></textarea>
    </div>
    <div class="editor">
      <label><strong>Word Equation</strong><button id="copyWordBtn" class="copyBtn">Copy Word Equation</button></label>
      <textarea id="wordOut" placeholder="Word equation output…" readonly></textarea>
    </div>
  </div>

  <div id="keyboard">
    <div class="tabs" id="tabs"></div>
    <div class="keys" id="keys" tabindex="0"></div>
  </div>

  <div id="tests">
    <button id="run">Run tests</button>
    <div id="log"></div>
  </div>

  <script>
    /* ---------------- Utilities ---------------- */
    function mjxTypeset(el, tries=0){
      if(!window.MathJax){ if(tries<200) { setTimeout(()=>mjxTypeset(el,tries+1),25); return; } else { return; } }
      const MJ=window.MathJax;
      if(MJ && typeof MJ.typeset==='function') { MJ.typeset([el]); }
      else if(MJ && typeof MJ.typesetPromise==='function') { MJ.typesetPromise([el]); }
      else if(tries<200) { setTimeout(()=>mjxTypeset(el,tries+1),25); }
    }

    const ta=document.getElementById('ta');
    const mf2=document.getElementById('mf2');
    const preview=document.getElementById('preview');
    const status=document.getElementById('status');
    const keysEl=document.getElementById('keys');
    const wordOut=document.getElementById('wordOut');

    function getLatex(){ return ta.value; }

    /* ---------- LaTeX -> Word Equation conversion ---------- */
    function toWordEquation(latex) {
        let w = String(latex ?? '');
        w = w.replace(/\\:/g, ' '); // Convert \: to regular space
        w = w.replace(/\\overrightarrow\{([^}]+)\}/g, '\\vec{$1}'); // Convert \overrightarrow{AB} to \vec{AB}
        w = w.replace(/\\operatorname\{cis\}\(([^)]+)\)/g, '(\\cos($1)+i\\sin($1))');
        w = w.replace(/\\differentialD\s?/g, 'd');
        // Ensure Word keeps differential variable (especially theta, mu)
        w = w.replace(/d\\theta/g, 'd{\\theta}');
        w = w.replace(/d\\mu/g, 'd{\\mu}');
        w = w.replace(/\\implies/g, '\\Longrightarrow');
        w = w.replace(/\\lvert(.*?)\\rvert/g, '\\left|$1\\right|');
        w = w.replace(/\\operatorname\{proj\}_\{\\underset\{\\sim\}\{([^}]*)\}\}\s*\\underset\{\\sim\}\{([^}]*)\}/g, '{\\rm proj}_{$1\\below\\sim} $2\\below\\sim');
        w = w.replace(/\\operatorname\{proj\}_\{([^}]*)\}\\s*([A-Za-z])/g, '{\\rm proj}_$1\\ $2');
        w = w.replace(/\\operatorname\{proj\}\\s*_\{([^}]*)\}\\s*([A-Za-z])/g, '{\\rm proj}_$1\\ $2');
        w = w.replace(/\\operatorname\{proj\}_([A-Za-z])\\s*([A-Za-z])/g, '{\\rm proj}_$1\\ $2');
        w = w.replace(/\\operatorname\{proj\}_\{([^}]*)\}\\s*(?=\()/g, '{\\rm proj}_$1\\ ');
        w = w.replace(/\\operatorname\{proj\}\\s*_\{([^}]*)\}\\s*(?=\()/g, '{\\rm proj}_$1\\ ');
        w = w.replace(/\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g, function(match, inside) {
            let content = inside.trim().replace(/\\*$/, '') + '\\\\';
            return '\\left(\\begin{matrix}' + content + '\\end{matrix}\\right)';
        });
        w = w.replace(/\\underset\{\\sim\}\{([^}]+)\}/g, '$1\\below\\sim');
        w = w.replace(/\\underset\{([^}]+)\}\{([^}]+)\}/g, '$2\\below$1');
        w = w.replace(/\\operatorname\{([^}]+)\}/g, '{\\rm $1}');
        return w;
    }
    
    function syncFromMathLive() {
        const rawLatex = mf2.getValue('latex');
        const cleanLatex = rawLatex.replace(/\\differentialD\s?/g, 'd');
        if (ta.value !== cleanLatex) { ta.value = cleanLatex; }
        wordOut.value = toWordEquation(cleanLatex);
        preview.innerHTML = '$$' + cleanLatex + '$$';
        mjxTypeset(preview);
    }

    function syncFromTextArea() {
        const cleanLatex = ta.value;
        if (mf2.getValue() !== cleanLatex) { mf2.setValue(cleanLatex); }
        wordOut.value = toWordEquation(cleanLatex);
        preview.innerHTML = '$$' + cleanLatex + '$$';
        mjxTypeset(preview);
    }
    
    function render(){ syncFromMathLive(); }

    function insertLatex(x){
      try{
          if(mf2.executeCommand){ mf2.executeCommand('insert', x); }
          else if(mf2.insert){ mf2.insert(x); }
          else { mf2.value = (mf2.value||'') + x; }
      }catch(e){}
      syncFromMathLive();
    }
    
    mf2.addEventListener('input', syncFromMathLive);
    ta.addEventListener('input', syncFromTextArea);

    /* ---------- Cleanup: delete object when all boxes emptied ---------- */
    function normalizeLatexStr(L) {
        try {
            const EMPTY_SLOT = String.raw`\s*(?:\\placeholder\{\})?\s*`;
            const EMPTY_BRACE = String.raw`\{${EMPTY_SLOT}\}`;
            L = L.replace(new RegExp(String.raw`\\frac${EMPTY_BRACE}${EMPTY_BRACE}`, "g"), "");
            L = L.replace(new RegExp(String.raw`\\sqrt${EMPTY_BRACE}`, "g"), "");
            L = L.replace(new RegExp(String.raw`\\sqrt\[${EMPTY_SLOT}\]${EMPTY_BRACE}`, "g"), "");
            L = L.replace(new RegExp(String.raw`\\(dot|ddot)${EMPTY_BRACE}`, "g"), "");
            const rm = (open, close) => new RegExp(String.raw`\\left\s*${open}${EMPTY_SLOT}\\right\s*${close}`, 'g');
            L = L.replace(rm('\\(', '\\)'), "");
            L = L.replace(rm('\\[', '\\]'), "");
            L = L.replace(rm('\\{', '\\\\}'), "");
            L = L.replace(rm('\\|', '\\|'), "");
            L = L.replace(new RegExp(String.raw`\\int_${EMPTY_BRACE}\^${EMPTY_BRACE}${EMPTY_SLOT}(?:d[a-zA-Z]+)?`, "g"), "");
            L = L.replace(new RegExp(String.raw`\\(sum|prod)_${EMPTY_BRACE}\^${EMPTY_BRACE}${EMPTY_SLOT}`, "g"), "");
            L = L.replace(new RegExp(String.raw`\\(sum|prod)_\{n=${EMPTY_SLOT}\}\^${EMPTY_BRACE}${EMPTY_SLOT}`, "g"), "");
            L = L.replace(new RegExp(String.raw`\\int\s*${EMPTY_SLOT}(?:d[a-zA-Z]+)?(?![_^])`, "g"), "");
            L = L.replace(new RegExp(String.raw`\\lim_\{x\\to\s*${EMPTY_SLOT}\}${EMPTY_SLOT}`, "g"), "");
            L = L.replace(new RegExp(String.raw`\\lim_${EMPTY_BRACE}${EMPTY_SLOT}`, "g"), "");
            L = L.replace(new RegExp(String.raw`\\begin\{pmatrix\}(?:${EMPTY_SLOT}|&|\\\\|\s)*\\end\{pmatrix\}`, "g"), '');
        } catch (e) {
            console.warn('normalizeLatexStr normalization failed', e);
        }
        return L;
    }

    function cleanupEmptyStructures(){ try{ const b=mf2.getValue('latex')||'',a=normalizeLatexStr(b); if(a!==b){ mf2.setValue(a); syncFromMathLive(); } }catch(e){console.warn('cleanup failed',e)} }
    
    function configureMathLive() {
        if (!window.MathfieldElement || !mf2) return;
        mf2.setOptions({
            mathModeSpace: '\\:',
            removeExtraneousParentheses: true,
            virtualKeyboardMode: 'off',
            virtualKeyboards: '', // Added: Disable all virtual keyboards
            virtualKeyboardToggleEnabled: false, // Added: Hide keyboard toggle icon
            inlineShortcutToolbar: false // Added: Disable inline toolbar/menu
        });

        let isArmedForDeletion = false; // Tracks "armed" state for double-tap deletion

        // Reset armed state on non-deletion actions
        mf2.addEventListener('keydown', (ev) => {
            if (ev.key !== 'Backspace') {
                isArmedForDeletion = false;
            }
        });

        mf2.addEventListener('input', (ev) => {
            if (ev.inputType !== 'deleteContentBackward' && ev.inputType !== 'deleteContentForward') {
                isArmedForDeletion = false;
            }
        });

        mf2.addEventListener('focus', () => { isArmedForDeletion = false; });
        mf2.addEventListener('blur', () => {
            cleanupEmptyStructures();
            isArmedForDeletion = false;
        });
        mf2.addEventListener('move-out', () => {
            cleanupEmptyStructures();
            isArmedForDeletion = false;
        });

        // Custom Backspace handling inspired by Word for Mac Equation Editor
        // - Navigation between boxes with Backspace when empty (non-first boxes)
        // - Double-tap to delete entire symbol when in first empty box
        // - Placeholders (boxes) persist until structure is deleted
        mf2.addEventListener('keydown', (ev) => {
            if (ev.key !== 'Backspace') return;
            ev.preventDefault();

            const sel = mf2.selection;
            if (!sel.isCollapsed) {
                mf2.executeCommand('deleteBackward');
                isArmedForDeletion = false;
                syncFromMathLive();
                return;
            }

            const position = sel.start;
            // Get atom at current position (assuming MathLive model access)
            const atom = mf2.model.at(position - 1); // Atom before cursor
            if (!atom) {
                mf2.executeCommand('deleteBackward');
                syncFromMathLive();
                return;
            }

            // Check if cursor is at the start of an empty placeholder/box
            const isEmptyBox = atom.type === 'placeholder' && position === atom.range.end;

            if (!isEmptyBox) {
                // Normal deletion
                mf2.executeCommand('deleteBackward');
                isArmedForDeletion = false;
                syncFromMathLive();
                return;
            }

            // Determine if this is the "first" box in the symbol (e.g., numerator in fraction)
            const path = mf2.model.path || mf2.model.getPath(position);
            const branch = path[path.length - 1];
            const siblings = branch.parent[branch.branch] || [];
            const boxIndex = siblings.indexOf(atom);
            const isFirstBox = boxIndex === 0;

            if (!isFirstBox) {
                // Navigate to previous box (like Word: Backspace moves to prior placeholder)
                mf2.executeCommand('moveToPrevious');
                isArmedForDeletion = false;
                syncFromMathLive();
                return;
            }

            // In first empty box: double-tap logic
            if (isArmedForDeletion) {
                // Second tap: delete the entire symbol/structure
                mf2.executeCommand('moveToGroupStart');
                mf2.executeCommand('extendToGroupEnd');
                mf2.executeCommand('delete');
                isArmedForDeletion = false;
            } else {
                // First tap: arm for deletion, appears to do nothing (cursor stays)
                isArmedForDeletion = true;
            }

            syncFromMathLive();
        });

        // Protect navigation into fixed subscripts like \underset{\sim}{} (only main box editable)
        mf2.addEventListener('keydown', (ev) => {
            if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(ev.key)) return;

            const position = mf2.position;
            const path = mf2.model.getPath(position);
            if (path.length < 2) return;

            const parent = path[path.length - 2];
            const branch = path[path.length - 1].branch;

            let isProtected = false;
            if (parent.type === 'underset' && parent.subscript?.length > 0) {
                const subAtom = parent.subscript[0];
                isProtected = subAtom.command === 'sim' || subAtom.value === '~';
            }

            if (isProtected) {
                ev.preventDefault(); // Block entry into subscript
                if (ev.key === 'ArrowDown' || (ev.key === 'ArrowRight' && position === parent.body[parent.body.length - 1].range.end)) {
                    // Skip over subscript, move to next element after structure
                    mf2.executeCommand('moveToNext');
                } else if (ev.key === 'ArrowUp' || (ev.key === 'ArrowLeft' && position === parent.subscript[0].range.start)) {
                    // Skip back to before structure
                    mf2.executeCommand('moveToPrevious');
                }
            }
        });

        // Redirect selection if it lands in protected subscript
        mf2.addEventListener('selection-did-change', () => {
            try {
                const sel = mf2.selection;
                if (!sel.isCollapsed) return;
                const position = sel.start;
                const path = mf2.model.getPath(position);
                if (path.length < 2) return;
                const parent = path[path.length - 2];
                const branch = path[path.length - 1].branch;
                if (parent.type === 'underset' && branch === 'subscript' && parent.subscript?.length > 0) {
                    const subAtom = parent.subscript[0];
                    if (subAtom.command === 'sim' || subAtom.value === '~') {
                        // Redirect to end of main body
                        mf2.position = parent.body[parent.body.length - 1].range.end;
                    }
                }
            } catch (e) {
                console.warn('Selection change handler error:', e);
            }
        });

        // Handle deletion of atomic structures like vectors
        function tryDeleteAtomicObject(direction = 'back') {
            try {
                const S = '\uE000'; // Sentinel
                mf2.executeCommand('insert', S);
                const withSentinel = mf2.getValue('latex') || '';
                mf2.executeCommand('undo');

                const idx = withSentinel.indexOf(S);
                if (idx === -1) return false;

                const left = withSentinel.slice(0, idx);
                const right = withSentinel.slice(idx + S.length);

                const atomicPatternEnd = /\\underset\{\\sim\}\{[a-zA-Z]\}$/;
                const atomicPatternStart = /^\\underset\{\\sim\}\{[a-zA-Z]\}/;

                if (direction === 'back') {
                    const match = left.match(atomicPatternEnd);
                    if (match) {
                        mf2.setValue(left.slice(0, -match[0].length) + right);
                        return true;
                    }
                } else if (direction === 'fwd') {
                    const match = right.match(atomicPatternStart);
                    if (match) {
                        mf2.setValue(left + right.slice(match[0].length));
                        return true;
                    }
                }
                return false;
            } catch (e) {
                console.warn('Atomic deletion failed:', e);
                return false;
            }
        }

        mf2.addEventListener('beforeinput', (ev) => {
            if (ev.inputType === 'deleteContentBackward' || ev.inputType === 'deleteContentForward') {
                if (tryDeleteAtomicObject(ev.inputType === 'deleteContentBackward' ? 'back' : 'fwd')) {
                    ev.preventDefault();
                    syncFromMathLive();
                }
            }
        });
    }
    
    /* ---------------- Keyboard (tabs + keys) ---------------- */
    const tabs=[{id:'calc',label:'Calculus'},{id:'func',label:'Functions'},{id:'sym',label:'Symbols'},{id:'vec',label:'Vectors'},{id:'greek',label:'Greek'},{id:'complex',label:'Complex'},{id:'sets',label:'Sets'}];
    const allLetters=Array.from('abcdefghijklmnopqrstuvwxyz');
    function vectorKey(b,d,c){const a=c?c.concat(allLetters.filter(e=>!c.includes(e))):allLetters.slice();return{base:b,currentVar:d,insert:`${b}{${d}}`,display:`${b}{${d}}`,options:a,isSelectable:!0}}
    
    const layouts={
        calc:[
            {display:'\\int_{\\square}^{\\square} \\square\\,dx',insert:'\\int_{\\placeholder{}}^{\\placeholder{}} \\placeholder{} dx'},
            {display:'\\int \\square\\,dx', insert:'\\int \\placeholder{} dx'},
            {display:'\\sum_{n=\\square}^{\\square} \\square',insert:'\\sum_{n=\\placeholder{}}^{\\placeholder{}} \\placeholder{}'},
            {display:'\\prod_{n=\\square}^{\\square} \\square',insert:'\\prod_{n=\\placeholder{}}^{\\placeholder{}} \\placeholder{}'},
            {display:'\\lim_{x\\to\\square} \\square',insert:'\\lim_{x\\to\\placeholder{}} \\placeholder{}'},
            {display:'\\frac{d}{dx}(\\square)',insert:'\\frac{d}{dx}\\left(\\placeholder{}\\right)'},
            {display:'\\left.\\square\\right|_{\\square}^{\\square}',insert:'\\left.\\placeholder{}\\right|_{\\placeholder{}}^{\\placeholder{}}'},
            {display:'\\sqrt{\\square}',insert:'\\sqrt{\\placeholder{}}'},
            {display:'\\sqrt[\\square]{\\square}',insert:'\\sqrt[\\placeholder{}]{\\placeholder{}}'}
        ],
        func:[{display:'\\sin(\\square)',insert:'\\sin(\\placeholder{})'},{display:'\\cos(\\square)',insert:'\\cos(\\placeholder{})'},{display:'\\tan(\\square)',insert:'\\tan(\\placeholder{})'},{display:'\\sin^{-1}(\\square)',insert:'\\sin^{-1}(\\placeholder{})'},{display:'\\cos^{-1}(\\square)',insert:'\\cos^{-1}(\\placeholder{})'},{display:'\\tan^{-1}(\\square)',insert:'\\tan^{-1}(\\placeholder{})'},{display:'\\ln(\\square)',insert:'\\ln(\\placeholder{})'},{display:'\\log_{\\square}(\\square)',insert:'\\log_{\\placeholder{}}(\\placeholder{})'},{display:'e^{\\square}',insert:'e^{\\placeholder{}}'},{display:'\\lvert \\square \\rvert',insert:'\\lvert \\placeholder{} \\rvert'}],
        sym:[
            {display:'>',insert:'>'},
            {display:'<',insert:'<'},
            {display:'\\geq',insert:'\\geq'},
            {display:'\\leq',insert:'\\leq'},
            {display:'\\pm', insert:'\\pm'},
            {display:'\\angle', insert: '\\angle'},
            {display:'^{\\circ}', insert:'^{\\circ}'},
            {display:'\\infty',insert:'\\infty'},
            {display:'\\neq',insert:'\\neq'},
            {display:'\\approx',insert:'\\approx'},
            {display:'\\equiv',insert:'\\equiv'},
            {display:'\\to',insert:'\\to'},
            {display:'\\implies',insert:'\\implies'},
            {display:'\\iff',insert:'\\iff'}
        ],
        vec:[
            vectorKey('\\vec','v',['v','u','w','r','a']),
            vectorKey('\\dot','x',['x','y','z','r','v']),
            vectorKey('\\ddot','x',['x','y','z','r','a']),
            {display:'\\operatorname{proj}_{\\underset{\\sim}{\\square}}\\underset{\\sim}{\\square}',insert:'\\operatorname{proj}_{\\underset{\\sim}{\\placeholder{}}}\\underset{\\sim}{\\placeholder{}}'},
            {
                isSelectable: true,
                base: '\\underset{\\sim}',
                currentVar: '\\placeholder{}',
                insert: '\\underset{\\sim}{\\placeholder{}}',
                display: '\\underset{\\sim}{\\square}',
                options: [
                    { value: '\\placeholder{}', text: '□' },
                    'a','b','c','u','v','w','r',
                    ...allLetters.filter(l => !['a','b','c','u','v','w','r'].includes(l))
                ]
            },
            {display:'\\underset{\\sim}{i}',insert:'\\underset{\\sim}{i}'},
            {display:'\\underset{\\sim}{j}',insert:'\\underset{\\sim}{j}'},
            {display:'\\underset{\\sim}{k}',insert:'\\underset{\\sim}{k}'},
            {display:'\\begin{pmatrix} \\square \\\\ \\square \\end{pmatrix}',insert:'\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}'},
            {display:'\\begin{pmatrix} \\square \\\\ \\square \\\\ \\square \\end{pmatrix}',insert:'\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}'},
            {display:'\\overrightarrow{\\square}',insert:'\\overrightarrow{\\placeholder{}}'} // New button for \overrightarrow{AB}
        ],
        greek:[{display:'\\alpha',insert:'\\alpha'},{display:'\\beta',insert:'\\beta'},{display:'\\gamma',insert:'\\gamma'},{display:'\\delta',insert:'\\delta'},{display:'\\theta',insert:'\\theta'},{display:'\\lambda',insert:'\\lambda'},{display:'\\mu',insert:'\\mu'},{display:'\\sigma',insert:'\\sigma'},{display:'\\omega',insert:'\\omega'},{display:'\\Delta',insert:'\\Delta'}],
        complex:[
            {
                isSelectable: true,
                keyType: 'cis',
                currentVar: '\\theta',
                display: '\\operatorname{cis}(\\theta)',
                insert: '\\cos(\\theta)+i\\sin(\\theta)',
                options: ['\\theta', '\\alpha', '\\beta', '\\gamma']
            },
            {
                isSelectable: true,
                keyType: 'cos-isin',
                currentVar: '\\theta',
                display: '\\cos(\\theta)+i\\sin(\\theta)',
                insert: '\\cos(\\theta)+i\\sin(\\theta)',
                options: ['\\theta', '\\alpha', '\\beta', '\\gamma']
            },
            {display:'|z|',insert:'|z|'},
            {display:'arg(z)',insert:'arg(z)'},
            {display:'\\overline{z}',insert:'\\overline{z}'},
            {display:'Re(z)',insert:'Re(z)'},
            {display:'Im(z)',insert:'Im(z)'},
            
        ],
        sets:[{display:'\\in',insert:'\\in'},{display:'\\mathbb{Z}',insert:'\\mathbb{Z}'},{display:'\\mathbb{Z}^+',insert:'\\mathbb{Z}^+'},{display:'\\mathbb{N}',insert:'\\mathbb{N}'},{display:'\\mathbb{Q}',insert:'\\mathbb{Q}'},{display:'\\mathbb{R}',insert:'\\mathbb{R}'},{display:'\\mathbb{C}',insert:'\\mathbb{C}'}]
    };

    function buildTabs(){const a=document.getElementById('tabs');a.innerHTML='';tabs.forEach(c=>{const b=document.createElement('div');b.textContent=c.label;b.className='tab';b.onclick=()=>activateTab(c.id);a.appendChild(b)});activateTab('calc')}
    function buildKeys(c) {
        const a = document.getElementById('keys');
        a.innerHTML = '';
        (layouts[c] || []).forEach((d, e) => {
            if (d.isSelectable) {
                const f = document.createElement('div');
                f.className = 'key';
                f.setAttribute('data-idx', e);
                f.tabIndex = 0 === e ? 0 : -1;
                
                const mathContent = document.createElement('div');
                const selector = document.createElement('select');
                selector.className = 'selector';

                d.options.forEach(opt => {
                    const h = document.createElement('option');
                    let val, txt;
                    if (typeof opt === 'object' && opt.value !== undefined) {
                        val = opt.value;
                        txt = opt.text;
                    } else {
                        val = opt;
                        txt = opt;
                    }
                    h.value = val;
                    h.innerHTML = txt; // Use text for display in dropdown
                    if (val === d.currentVar) h.selected = true;
                    selector.appendChild(h);
                });

                ['click', 'mousedown', 'touchstart'].forEach(i => {
                    selector.addEventListener(i, h => h.stopPropagation(), { capture: true });
                });
                
                selector.addEventListener('change', i => {
                    d.currentVar = i.target.value;
                    const currentVal = d.currentVar;

                    if (d.keyType === 'cis') {
                        d.insert = `\\cos(${currentVal})+i\\sin(${currentVal})`;
                        d.display = `\\operatorname{cis}(${currentVal})`;
                    } else if (d.keyType === 'cos-isin') {
                        d.insert = `\\cos(${currentVal})+i\\sin(${currentVal})`;
                        d.display = d.insert;
                    } else { 
                        d.insert = `${d.base}{${currentVal}}`;
                        d.display = (currentVal === '\\placeholder{}') ? `${d.base}{\\square}` : `${d.base}{${currentVal}}`;
                    }
                    
                    mathContent.innerHTML = '$$' + d.display + '$$';
                    mjxTypeset(mathContent);
                });
                
                mathContent.innerHTML = '$$' + d.display + '$$';
                f.addEventListener('click', i => { if (i.target !== selector) insertLatex(d.insert); });

                f.appendChild(mathContent);
                f.appendChild(selector);
                a.appendChild(f);
                mjxTypeset(f);
            } else {
                const f = document.createElement('button');
                f.type = 'button';
                f.className = 'key';
                f.setAttribute('data-idx', e);
                f.tabIndex = 0 === e ? 0 : -1;
                f.innerHTML = '$$' + d.display + '$$';
                f.addEventListener('click', () => insertLatex(d.insert));
                a.appendChild(f);
                mjxTypeset(f);
            }
        });
    }
    function activateTab(a){document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));const c=tabs.find(b=>b.id===a);document.querySelectorAll('.tab').forEach(b=>{if(c&&b.textContent===c.label) b.classList.add('active')});buildKeys(a)}
    let currentIndex=0;function focusCurrentKey(){const a=[...document.querySelectorAll('.key')];a.forEach((b,c)=>{b.tabIndex=c===currentIndex?0:-1});const b=a[currentIndex];b&&b.focus()}keysEl.addEventListener('keydown',a=>{const b=[...document.querySelectorAll('.key')];if(b.length){if('ArrowRight'===a.key){a.preventDefault();currentIndex=(currentIndex+1)%b.length;focusCurrentKey()}else if('ArrowLeft'===a.key){a.preventDefault();currentIndex=(currentIndex-1+b.length)%b.length;focusCurrentKey()}else if('Enter'===a.key||' '===a.key){a.preventDefault();b[currentIndex].click()}}});buildTabs();

    /* ---------------- Load MathLive ---------------- */
    async function loadMathLive(){
        const sources = {
            coreCss: ['https://unpkg.com/mathlive/dist/mathlive.core.css', 'https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.core.css'],
            css: ['https://unpkg.com/mathlive/dist/mathlive.css', 'https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.css'],
            js: ['https://unpkg.com/mathlive/dist/mathlive.min.js', 'https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.min.js']
        };
        let loaded = false;

        for (const url of sources.coreCss) {
            try {
                await new Promise((resolve, reject) => {
                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = url;
                    link.onload = () => resolve();
                    link.onerror = () => reject();
                    document.head.appendChild(link);
                });
                loaded = true;
                break;
            } catch {}
        }

        for (const url of sources.css) {
            try {
                await new Promise((resolve, reject) => {
                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = url;
                    link.onload = () => resolve();
                    link.onerror = () => reject();
                    document.head.appendChild(link);
                });
                break;
            } catch {}
        }

        for (const url of sources.js) {
            try {
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = url;
                    script.defer = true;
                    script.onload = () => resolve();
                    script.onerror = () => reject();
                    document.head.appendChild(script);
                });
                status.textContent = 'MathLive loaded from ' + url;
                loaded = true;
                break;
            } catch {}
        }

        return loaded;
    }
    (async()=>{const a=await loadMathLive();if(a&&customElements.get('math-field')){status.textContent='MathLive ready';setTimeout(configureMathLive,100);}else{status.textContent='Fallback mode';}render()})();

    /* ---------------- Copy buttons ---------------- */
    async function copyToClipboard(a,b){try{if(navigator.clipboard&&navigator.clipboard.writeText){await navigator.clipboard.writeText(a);status.textContent=`Copied ${b} ✓`;return}}catch(c){console.warn('clipboard API failed',c)}const d=document.createElement('textarea');d.value=a;d.setAttribute('readonly','');d.style.position='fixed';d.style.left='-9999px';document.body.appendChild(d);d.select();try{document.execCommand('copy');status.textContent=`Copied ${b} ✓`}catch(c){status.textContent=`Copy ${b} failed`}finally{document.body.removeChild(d)}}
    document.getElementById('copyBtn').addEventListener('click',()=>copyToClipboard(getLatex()??'','LaTeX'));
    document.getElementById('copyWordBtn').addEventListener('click',()=>copyToClipboard(wordOut.value??'','Word Equation'));

    /* ---------- Tests ---------- */
    function log(a){const b=document.getElementById('log');b.textContent+=(b.textContent?'\n':'')+a}function clearLog(){document.getElementById('log').textContent=''}
    function runTests(){clearLog();activateTab('vec');const a=document.querySelector('.key select');if(!a){log('FAIL: No selector key found on "Vectors" tab.');return}log('Running tests on a selectable key...');log(26<=a.options.length?'PASS: selector contains at least 26 letters':'FAIL: selector size = '+a.options.length);const b=getLatex(),c=a.value;a.value='v'===a.value?'u':'v';a.dispatchEvent(new Event('change',{bubbles:!0}));log(b===getLatex()?'PASS: change selection does not insert':'FAIL: selection triggered insertion');const d=getLatex();a.parentElement&&a.parentElement.click();log(getLatex().length>d.length?'PASS: clicking key inserts':'FAIL: clicking key did not insert');a.value=c;a.dispatchEvent(new Event('change',{bubbles:!0}));activateTab('calc')}
    document.getElementById('run').addEventListener('click',runTests);
  </script>
</body>
</html>
