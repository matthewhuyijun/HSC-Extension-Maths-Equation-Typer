<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HSC Ext 2 ‚Äì Visual Math Printer (Dual Inputs with Vectors)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
        :root {
            color-scheme: light;
            --color-bg: #f8fafc;
            --color-text: #111111;
            --ink: #111827;
            --muted: #6b7280;
            --color-header-bg: #2563eb;
            --color-header-text: #ffffff;
            --color-toolbar-bg: #e2e8f0;
            --color-surface: #ffffff;
            --color-surface-alt: #f1f5f9;
            --color-border: #cbd5e1;
            --color-border-strong: #cbd5e1;
            --color-tab-bg: #ffffff;
            --color-tab-text: #111111;
            --color-tab-active-bg: #2563eb;
            --color-tab-active-text: #ffffff;
            --color-tooltip-bg: rgba(51, 51, 51, 0.95);
            --color-tooltip-text: #ffffff;
            --color-control-bg: #ffffff;
            --color-control-text: #111111;
            --color-caret: #1d4ed8;
            /* Copy button palette (from chem tryper) */
            --copy-bg: #ffffff;
            --copy-border: rgba(15, 23, 42, 0.15);
            --copy-ink: #0f172a;
            --copy-hover-bg: var(--color-tab-active-bg);
            --copy-hover-ink: var(--color-tab-active-text);
            --copy-hover-border: rgba(37, 99, 235, 0.65);
        }

        [data-theme="dark"] {
            color-scheme: dark;
            --color-bg: #0f172a;
            --color-text: #e2e8f0;
            --ink: #e2e8f0;
            --muted: #94a3b8;
            --color-header-bg: #1d4ed8;
            --color-header-text: #e2e8f0;
            --color-toolbar-bg: #1f2937;
            --color-surface: #1e293b;
            --color-surface-alt: #111827;
            --color-border: #334155;
            --color-border-strong: #1f2937;
            --color-tab-bg: #1f2937;
            --color-tab-text: #e2e8f0;
            --color-tab-active-bg: #2563eb;
            --color-tab-active-text: #e2e8f0;
            --color-tooltip-bg: rgba(15, 23, 42, 0.9);
            --color-tooltip-text: #f8fafc;
            --color-control-bg: #1f2937;
            --color-control-text: #e2e8f0;
            --color-caret: #93c5fd;
            /* Copy button palette (from chem tryper) */
            --copy-bg: rgba(15, 23, 42, 0.85);
            --copy-border: rgba(148, 163, 184, 0.45);
            --copy-ink: #f8fafc;
            --copy-hover-bg: var(--color-tab-active-bg);
            --copy-hover-ink: var(--color-tab-active-text);
            --copy-hover-border: rgba(37, 99, 235, 0.65);
        }

        * { box-sizing: border-box; }
        html, body { overflow-x: hidden; overflow-y: auto; overscroll-behavior: contain; touch-action: pan-y; }
        body { font-family: sans-serif; margin: 0; padding: 0; background: var(--color-bg); color: var(--color-text); display: flex; flex-direction: column; min-height: 100vh; }
        header { padding: 12px 16px; background: var(--color-header-bg); color: var(--color-header-text); display: flex; justify-content: space-between; align-items: center; gap: 16px; flex-wrap: wrap; }
        .header-left { display: flex; align-items: center; gap: 16px; flex-wrap: wrap; }
        header h1 { margin: 0; font-size: 18px; line-height: 1.25; font-weight: 600; }
        .header-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .copyBtn,
        .header-copy {
            appearance: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 18px;
            border-radius: 999px;
            border: 1px solid var(--copy-border);
            background: var(--copy-bg);
            color: var(--copy-ink);
            font-weight: 600;
            letter-spacing: -0.01em;
            cursor: pointer;
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.25);
            transition: background .18s ease, color .18s ease, box-shadow .18s ease, transform .12s ease, border-color .18s ease;
        }
        .copyBtn { font-size: 12px; }
        .header-copy { font-size: 14px; }
        .copyBtn:hover,
        .header-copy:hover,
        .copyBtn:focus-visible,
        .header-copy:focus-visible {
            background: var(--copy-hover-bg);
            color: var(--copy-hover-ink);
            border-color: var(--copy-hover-border);
            box-shadow: 0 4px 14px rgba(15, 23, 42, 0.2);
        }
        .copyBtn:focus-visible,
        .header-copy:focus-visible { outline: 2px solid rgba(37, 99, 235, 0.6); outline-offset: 2px; }
        .copyBtn:active,
        .header-copy:active { transform: translateY(1px); box-shadow: 0 2px 8px rgba(15, 23, 42, 0.25); }
        .header-controls { display: flex; align-items: center; gap: 12px; }
        #status { font-size: 12px; color: var(--color-header-text); font-weight: 600; }
        .theme-switcher { display: flex; align-items: center; gap: 6px; font-size: 12px; color: var(--color-header-text); }
        .theme-switcher select { padding: 2px 6px; }
        .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; border: 0; padding: 0; margin: -1px; }
        .theme-segmented { display: inline-flex; align-items: center; gap: 6px; padding: 4px; background: var(--copy-bg); border: 1px solid var(--copy-border); border-radius: 12px; box-shadow: 0 6px 18px rgba(15, 23, 42, 0.15); }
        .theme-segmented input { position: absolute; opacity: 0; pointer-events: none; }
        .theme-segmented label { cursor: pointer; display: inline-flex; align-items: center; justify-content: center; min-width: 36px; height: 28px; padding: 0 8px; border-radius: 8px; color: var(--copy-ink); opacity: 0.7; user-select: none; }
        .theme-segmented input:checked + label { background: var(--color-surface); opacity: 1; box-shadow: 0 1px 1px rgba(15, 23, 42, 0.08), inset 0 0 0 1px var(--copy-border); }
        .theme-segmented label:hover { opacity: 0.9; }

        /* --- LAYOUT/STACKING FIXES --- */
        /* The select dropdowns on the 2nd row of the toolbar were getting covered by the tabs below. */
        /* Create clear stacking order: toolbar above tabs, and selectors above everything. */
        /* Keys need a stacking context so their absolutely positioned children (selectors/tooltips) can layer */
        .key { position: relative; border-radius: 14px; border: 1px solid var(--key-border); background: var(--key-surface); color: var(--color-text); display: flex; align-items: center; justify-content: center; padding: 12px; width: 100%; box-shadow: 0 12px 28px rgba(15, 23, 42, 0.12); transition: transform .12s ease, box-shadow .12s ease, background-color .2s ease, border-color .2s ease; --key-content-max-height: calc(100% - 16px); }
        .key:active { transform: translateY(1px); box-shadow: 0 1px 3px rgba(15, 23, 42, 0.1); }
        .key:hover { background: color-mix(in srgb, var(--color-tab-active-bg) 18%, var(--key-surface)); color: var(--color-tab-active-text); border-color: var(--color-tab-active-bg); }
        /* Better expanded area sizing - FIXED HEIGHT FOR ALL TABS */
        #expanded-area .key {
            height: 120px !important;
            min-height: 120px !important;
            max-height: 120px !important;
            width: 100%;
            padding: 12px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #expanded-area .key > div {
            max-height: var(--key-content-max-height);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        #tabs_wrapper {
            background: var(--panel-surface);
            border: 1px solid var(--panel-border);
            border-radius: 18px;
            position: relative;
            z-index: 5;
            width: 95%;
            max-width: 1200px;
            margin: 16px auto 0;
            padding: 14px 16px;
            box-shadow: 0 18px 36px var(--panel-shadow);
        }
        .tabs {
            display: flex;
            gap: 8px;
            padding: 0;
            flex-wrap: wrap;
            width: 100%;
        }
        .tab {
            padding: 10px 16px;
            border: 1px solid var(--color-border);
            border-radius: 12px;
            cursor: pointer;
            background: var(--color-tab-bg);
            color: var(--color-tab-text);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 12px;
            font-weight: 600;
            transition: background .2s ease, color .2s ease, border-color .2s ease;
            flex: 1;
            min-width: 0;
            text-align: center;
        }
        .tab:hover { background: var(--color-tab-active-bg); color: var(--color-tab-active-text); border-color: var(--color-tab-active-bg); box-shadow: 0 12px 22px rgba(15,23,42,0.15); }
        .tab::after { content: ''; }
        .tab[data-expanded="true"] { background: var(--color-tab-active-bg); color: var(--color-tab-active-text); border-color: var(--color-tab-active-bg); }
        .tab[data-expanded="true"]::after { content: ''; }
        .tab:focus-visible { outline: 2px solid var(--color-tab-active-bg); outline-offset: 2px; }

        button,
        select {
            background: var(--color-control-bg);
            color: var(--color-control-text);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 12px;
            padding: 3px 8px;
            line-height: 1.25;
        }
        button:focus-visible, select:focus-visible { outline: 2px solid var(--color-tab-active-bg); outline-offset: 2px; }
        .hover-area { position: relative; display: block; width: 100%; }
        #expanded-area {
            --expanded-columns: 1;
            display: grid;
            grid-template-columns: repeat(var(--expanded-columns), minmax(0, 1fr));
            gap: 16px;
            padding: 20px;
            background: var(--panel-surface);
            border: 1px solid var(--panel-border);
            border-radius: 18px;
            margin: 16px auto 12px;
            width: 95%;
            max-width: 1200px;
            position: static;
            z-index: auto;
            overflow: visible;
            box-shadow: 0 22px 40px var(--panel-shadow);
        }
        #expanded-area:hover { background: color-mix(in srgb, var(--panel-surface) 92%, white); }
        .hidden { display: none; }

        .key-row { display: grid; gap: 16px; width: 100%; grid-auto-rows: 1fr; }
        .key-row .key { 
            height: 100%; 
            min-height: 120px !important;
            max-height: 120px !important;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 12px;
            border-radius: 14px;
        }
        
        .key-row .key > * {
            max-height: 100%;
            overflow: hidden;
        }

        #mainContent { width: 100%; margin: 12px auto 0; padding: 0 0 48px; display: flex; flex-direction: column; gap: 24px; flex: 1 1 auto; align-items: center; }
        /* Match chem-tryper card structure */
        .section-card { background: var(--panel-surface); border: 1px solid var(--panel-border); border-radius: 18px; box-shadow: 0 22px 40px var(--panel-shadow); overflow: visible; width: 95%; max-width: 1200px; margin: 0 auto; }
        .section-card:first-of-type { margin-top: 0; }
        .section-card .card-body { padding: 28px 24px; width: 100%; margin: 0; }
        .section-card:first-of-type .card-body { padding-top: 28px; padding-bottom: 28px; }
        .section-card:last-of-type { margin-top: auto; }
        .card { background: color-mix(in srgb, var(--panel-surface) 96%, transparent); border: 1px solid color-mix(in srgb, var(--panel-border) 80%, transparent); border-radius: 18px; box-shadow: 0 18px 36px var(--panel-shadow); overflow: hidden; }
        .body { padding: 20px; }
        .stack { display: grid; gap: 18px; }

        /* È°∂ÈÉ®È¢ÑËßà‰ªç‰∏∫Áã¨Á´ãÂç°Áâá */
        #preview { min-height: 72px; padding: 24px; border: none; background: color-mix(in srgb, var(--panel-surface) 92%, white); color: var(--color-text); border-radius: 12px; border: 1px solid color-mix(in srgb, var(--panel-border) 75%, transparent); }

        /* Editor stack exactly like chem-tryper */
        #editorWrap { padding: 8px 0 16px; display: grid; gap: 20px; background: transparent; border: none; border-radius: 0; }
        .editor {
            position: relative;
            padding: 20px;
            border-radius: 18px;
            background: var(--key-surface);
            border: 1px solid var(--key-border);
            box-shadow: 0 18px 36px var(--panel-shadow);
            display: grid;
            gap: 16px;
        }
        .editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }
        .editor-header label,
        .editor label {
            display: block;
            font-size: 16px;
            font-weight: 600;
            color: var(--ink);
            letter-spacing: -0.01em;
            margin: 0;
        }
        .editor-header label span,
        .editor label span { display: block; }
        .editor button.copyBtn { margin-left: 0; }
        /* Input bars like chem-tryper */
        math-field, textarea { width: 100%; min-height: 52px; font-size: 19.8px; padding: 12px 14px; border: 1px solid color-mix(in srgb, var(--panel-border) 80%, transparent); border-radius: 14px; display: block; background: color-mix(in srgb, var(--panel-surface) 96%, transparent); color: var(--color-text); margin: 0; transition: border-color .2s ease, background .2s ease; box-shadow: inset 0 1px 3px rgba(2, 6, 23, 0.05); }
        #mf2 { min-height: 96px; }
        #ta,
        #wordOut { font-size: 16px; }
        textarea { resize: none; }
        math-field::part(content) { color: var(--color-text); }
        math-field::part(caret) { border-left: 3px solid var(--color-caret); }
        math-field .ML__paren.ML__delim { min-height: 100% !important; }
        math-field .ML__matrix { position: relative; }
        math-field .ML__matrix .ML__delim { height: 100% !important; }

        /* Make the small variable selector dropdowns always layer above tabs/expanded area */
        .selector { font-size: 14px; position: absolute; top: 2px; right: 2px; z-index: 1000; background: var(--color-control-bg); color: var(--color-control-text); border: 1px solid var(--color-border); border-radius: 6px; padding: 2px 10px; min-height: 28px; min-width: 64px; }
        /* Reserve space at the top of keys that have a selector to prevent overlap */
        .key.has-selector { padding-top: 36px; }
        /* Ensure math content within keys wraps and centers nicely below selector */
        .key.has-selector .math-display { display: flex; align-items: center; justify-content: center; text-align: center; }
        .selector option { font-size: 14px; }
        .tooltip { display: none; position: absolute; background: var(--color-tooltip-bg); color: var(--color-tooltip-text); padding: 4px 8px; border-radius: 4px; font-size: 12px; top: calc(100% + 6px); left: 50%; transform: translateX(-50%); white-space: nowrap; z-index: 900; box-shadow: 0 6px 16px rgba(15,23,42,0.25); }

        /* (removed) hint corner and popover styles */

        math-field::part(virtual-keyboard-toggle) { display: none !important; visibility: hidden !important; }
        math-field::part(menu-toggle) { display: none !important; visibility: hidden !important; }

        /* Shrink MathJax output inside keys */
        /* Default: make symbols larger in non-vector tabs */
        #expanded-area[data-tab-id]:not([data-tab-id="vec"]) .key > div {
            max-height: 100%;
        }
        #expanded-area[data-tab-id]:not([data-tab-id="vec"]) .key mjx-container {
            font-size: clamp(1.05rem, 3.6vw, 1.6rem) !important;
            max-height: 100% !important;
            max-width: 100% !important;
            overflow: hidden !important;
            line-height: 1.05 !important;
        }
        #expanded-area[data-tab-id]:not([data-tab-id="vec"]) .key mjx-container svg {
            max-height: 100% !important;
            max-width: 100% !important;
            width: auto !important;
            height: 100% !important;
        }
        #expanded-area[data-tab-id]:not([data-tab-id="vec"]) .key mjx-container mjx-math,
        #expanded-area[data-tab-id]:not([data-tab-id="vec"]) .key mjx-container *,
        #expanded-area[data-tab-id]:not([data-tab-id="vec"]) .key mjx-mrow,
        #expanded-area[data-tab-id]:not([data-tab-id="vec"]) .key mjx-mi,
        #expanded-area[data-tab-id]:not([data-tab-id="vec"]) .key mjx-mo,
        #expanded-area[data-tab-id]:not([data-tab-id="vec"]) .key mjx-mn {
            font-size: clamp(0.9rem, 3vw, 1.2rem) !important;
            line-height: 1.06 !important;
        }
        /* Vector tab: keep more compact to fit large constructs */
        #expanded-area[data-tab-id="vec"] .key mjx-container {
            font-size: clamp(0.8rem, 2.6vw, 1.1rem) !important;
            max-height: 100% !important;
            max-width: 100% !important;
            overflow: hidden !important;
            line-height: 1.05 !important;
        }
        #expanded-area[data-tab-id="vec"] .key mjx-container svg {
            max-height: 100% !important;
            max-width: 100% !important;
            width: auto !important;
            height: 100% !important;
        }
        #expanded-area[data-tab-id="vec"] .key mjx-container mjx-math,
        #expanded-area[data-tab-id="vec"] .key mjx-container *,
        #expanded-area[data-tab-id="vec"] .key mjx-mrow,
        #expanded-area[data-tab-id="vec"] .key mjx-mi,
        #expanded-area[data-tab-id="vec"] .key mjx-mo,
        #expanded-area[data-tab-id="vec"] .key mjx-mn {
            font-size: clamp(0.6rem, 2vw, 0.85rem) !important;
            line-height: 1.06 !important;
        }

        .math-display-text {
            font-family: 'Menlo', 'Courier New', monospace;
            font-size: 0.75rem;
            white-space: nowrap;
        }

/* === Pretty-up pack (drop-in overrides) === */

/* Font + smoother text */
html, body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }

/* Subtle gradient background */
:root {
  --bg-grad-1: radial-gradient(1200px 600px at 10% -10%, rgba(37,99,235,.10), transparent 60%),
               radial-gradient(900px 500px at 110% 10%, rgba(99,102,241,.10), transparent 60%);
  --panel-surface: rgba(244, 247, 255, 0.9);
  --panel-border: rgba(148, 163, 184, 0.35);
  --panel-shadow: rgba(30, 41, 59, 0.18);
  --key-surface: rgba(255, 255, 255, 0.96);
  --key-border: rgba(148, 163, 184, 0.38);
}
[data-theme="dark"] {
  --bg-grad-1: radial-gradient(1200px 600px at 10% -10%, rgba(37,99,235,.18), transparent 60%),
               radial-gradient(900px 500px at 110% 10%, rgba(99,102,241,.18), transparent 60%);
  --panel-surface: rgba(23, 33, 58, 0.88);
  --panel-border: rgba(63, 76, 110, 0.55);
  --panel-shadow: rgba(2, 6, 23, 0.32);
  --key-surface: rgba(30, 44, 76, 0.92);
  --key-border: rgba(84, 105, 150, 0.55);
}
body { background-image: var(--bg-grad-1); }

/* Header: soft gradient + nicer title */
header {
  background: linear-gradient(135deg, var(--color-header-bg), #3b82f6 55%, #6366f1);
  box-shadow: 0 8px 20px rgba(2, 6, 23, 0.28);
}
header h1 {
  letter-spacing: -0.01em;
  font-size: 20px;
  line-height: 1.2;
  position: relative;
}
header h1::after {
  content: "";
  position: absolute;
  left: 0; bottom: -6px;
  width: 100px; height: 3px;
  border-radius: 999px;
  background: linear-gradient(90deg, #ffffffaa, #c7d2fe 60%, transparent);
  filter: blur(.3px);
}

/* Cards: glassy, soft hover */
.section-card {
  border-radius: 18px;
  backdrop-filter: saturate(1.1) blur(6px);
  background: color-mix(in srgb, var(--color-surface) 86%, transparent);
  border: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent);
  transition: transform .15s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease;
}
.section-card:hover {
  transform: none;
  box-shadow: 0 16px 30px rgba(8, 15, 35, 0.18);
  background: color-mix(in srgb, var(--color-surface) 92%, transparent);
}

/* Tabs: pill-ish, floatier */
.tab {
  border-radius: 999px;
  padding: 8px 14px;
  box-shadow: 0 6px 14px rgba(2, 6, 23, 0.12);
}
#tabs { gap: 8px; padding: 10px; }

/* Expanded keys: tighter look + lift on hover */
#expanded-area { gap: 14px; border-radius: 18px; }
.key {
  border-radius: 14px;
  box-shadow: 0 10px 22px rgba(2, 6, 23, 0.12);
  transition: transform .12s ease, box-shadow .12s ease, background-color .2s ease, border-color .2s ease;
}
.key:hover { transform: translateY(-1px); }

/* Inputs: clearer focus ring */
math-field, textarea {
  border-radius: 10px;
  box-shadow: 0 1px 0 rgba(2, 6, 23, 0.04);
}
math-field:focus-within, textarea:focus {
  outline: 2px solid color-mix(in srgb, var(--color-tab-active-bg) 60%, white);
  outline-offset: 2px;
  border-color: var(--color-tab-active-bg);
}

/* Buttons: chunkier, friendlier */
.copyBtn, .header-copy {
  letter-spacing: 0;
  border-radius: 12px;
  padding: 9px 18px;
  box-shadow: 0 10px 24px rgba(2, 6, 23, 0.2);
}
.copyBtn:hover, .header-copy:hover {
  transform: translateY(-1px);
}

/* Preview area: gentle surface + inner spacing */
#preview {
  border-radius: 12px;
  background: color-mix(in srgb, var(--color-surface) 92%, transparent);
  border: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent);
}

/* Theme toggle chip: crisper */
.theme-segmented {
  border-radius: 14px;
  box-shadow: 0 8px 18px rgba(2, 6, 23, 0.18);
}
.theme-segmented input:checked + label {
  background: color-mix(in srgb, var(--color-surface) 85%, transparent);
}

/* Small motion for MathJax renders */
.math-render svg { transition: transform .12s ease; }
.key:hover .math-render svg { transform: translateY(-1px); }

/* === Subtle auto light/dark SVG wallpaper === */
:root {
  /* tiny dot grid for light mode */
  --wallpaper-light: url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'>\
<rect width='100%' height='100%' fill='none'/>\
<circle cx='14' cy='14' r='0.75' fill='%23cbd5e1' opacity='0.55'/>\
</svg>");
  /* tiny dot grid for dark mode */
  --wallpaper-dark: url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'>\
<rect width='100%' height='100%' fill='none'/>\
<circle cx='14' cy='14' r='0.75' fill='%23334155' opacity='0.55'/>\
</svg>");
  --wallpaper: var(--wallpaper-light);
}

/* your script already toggles data-theme on <html> */
[data-theme="dark"] {
  --wallpaper: var(--wallpaper-dark);
}

/* layer the wallpaper under any existing gradient/background */
body {
  background-image: var(--bg-grad-1, none), var(--wallpaper);
  background-size: auto, 28px 28px;          /* keep your gradient size as-is; dot grid at 28px */
  background-attachment: fixed, fixed;        /* subtle parallax feel, also prevents seams */
  background-position: center, center;
  background-repeat: no-repeat, repeat;
}

/* === Copy toast styles === */
#toast {
  position: fixed;
  left: 50%;
  bottom: 40px;
  transform: translateX(-50%) translateY(40px);
  background: rgba(34,197,94,0.95); /* green success */
  color: #fff;
  padding: 10px 18px;
  border-radius: 999px;
  font-size: 14px;
  font-weight: 700;
  letter-spacing: 0.01em;
  box-shadow: 0 12px 28px rgba(2,6,23,0.25);
  opacity: 0;
  pointer-events: none;
  transition: opacity .25s ease, transform .25s ease;
  z-index: 9999;
}
#toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}
    </style>
    <script>
        window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }, svg: { fontCache: 'global' } };
        window.whenMathJaxReady = window.whenMathJaxReady || function(){};
    </script>
     <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" defer onload="whenMathJaxReady()"></script>
</head>
<body>
    <header>
        <div class="header-left">
            <h1>HSC Ext 2 ‚Äì Visual Math Printer</h1>
            <div class="header-actions">
                <button type="button" class="header-copy" id="headerCopyLatex">Copy LaTeX</button>
                <button type="button" class="header-copy" id="headerCopyWord">Copy Word Equation</button>
            </div>
        </div>
        <div class="header-controls">
            <div id="status">Loading editor‚Ä¶</div>
            <label class="theme-switcher">
                <span class="visually-hidden">Theme</span>
                <div class="theme-segmented" role="radiogroup" aria-label="Theme selection">
                    <input type="radio" id="themeLight" name="themeSegment" value="light" aria-label="Light">
                    <label for="themeLight" title="Light">‚òÄÔ∏è</label>
                    <input type="radio" id="themeDark" name="themeSegment" value="dark" aria-label="Dark">
                    <label for="themeDark" title="Dark">üåô</label>
                    <input type="radio" id="themeSystem" name="themeSegment" value="system" aria-label="System">
                    <label for="themeSystem" title="System">üñ•Ô∏è</label>
                </div>
                <select id="themeMode" aria-label="Theme selection" class="visually-hidden">
                    <option value="system">System</option>
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                </select>
            </label>
        </div>
    </header>

    <div id="tabs_wrapper">
        <div class="tabs" id="tabs"></div>
    </div>
    
    <!-- Expanded area for full tab keys -->
    <div id="expanded-area"></div>

<div id="mainContent">
        <div class="section-card card">
            <div class="card-body body" id="preview"></div>
        </div>

        <div class="section-card card">
            <div class="card-body body stack" id="editorWrap">
      <div class="editor">
        <div class="editor-header">
          <label for="mf2"><span>Rendered Input (Editable)</span></label>
        </div>
        <math-field id="mf2" smart-fence letter-shape-style="tex" virtual-keyboard-mode="manual" remove-extraneous-parentheses="on" placeholder="Type here‚Ä¶"></math-field>
      </div>
      <div class="editor">
        <div class="editor-header">
          <label for="ta"><span>Raw LaTeX Input</span></label>
          <button id="copyBtn" class="copyBtn">Copy LaTeX</button>
        </div>
        <textarea id="ta" placeholder="Type or paste LaTeX here‚Ä¶"></textarea>
      </div>
      <div class="editor">
        <div class="editor-header">
          <label for="wordOut"><span>Word Equation</span></label>
          <button id="copyWordBtn" class="copyBtn">Copy Word Equation</button>
        </div>
        <textarea id="wordOut" placeholder="Word equation output‚Ä¶" readonly></textarea>
      </div>
        </div>
    </div>
    <div id="toast" role="status" aria-live="polite"></div>
    <script>
         function mjxTypeset(el, tries=0){
             if(!window.MathJax){ 
                 if(tries<200) { 
                     setTimeout(()=>mjxTypeset(el,tries+1),25); 
                     return; 
                 } else { 
                     console.warn('MathJax not available after 200 attempts');
                     return; 
                 } 
             }
             const MJ=window.MathJax;
             try {
                 if(MJ && typeof MJ.typeset==='function') { 
                     MJ.typeset([el]); 
                 } else if(MJ && typeof MJ.typesetPromise==='function') { 
                     MJ.typesetPromise([el]); 
                 } else if(tries<200) { 
                     setTimeout(()=>mjxTypeset(el,tries+1),25); 
                 }
             } catch(e) {
                 console.warn('MathJax typeset failed', e);
             }
         }

        const ta=document.getElementById('ta');
        const mf2=document.getElementById('mf2');
        const preview=document.getElementById('preview');
        const status=document.getElementById('status');
        const wordOut=document.getElementById('wordOut');
        const themeSelect=document.getElementById('themeMode');
        const themeSeg=document.querySelector('.theme-segmented');

        const THEME_STORAGE_KEY='theme-preference';
        const prefersDarkScheme=window.matchMedia('(prefers-color-scheme: dark)');
        const themeStorage={
            get(){ try{ return localStorage.getItem(THEME_STORAGE_KEY); }catch{ return null; } },
            set(value){ try{ localStorage.setItem(THEME_STORAGE_KEY, value); }catch{} }
        };
        const resolveTheme=(choice)=>choice==='system'?(prefersDarkScheme.matches?'dark':'light'):choice;
        function setDocumentTheme(theme){
            document.documentElement.setAttribute('data-theme', theme);
            document.documentElement.style.colorScheme=theme==='dark'?'dark':'light';
        }
        function applyTheme(choice){
            const resolved=resolveTheme(choice);
            setDocumentTheme(resolved);
            if(themeSelect&&themeSelect.value!==choice){ themeSelect.value=choice; }
            if(themeSeg){
                const input=themeSeg.querySelector(`input[value="${choice}"]`);
                if(input&& !input.checked){ input.checked=true; }
            }
        }
        applyTheme(themeStorage.get()||'system');
        if(themeSelect){
            themeSelect.addEventListener('change',event=>{
                const selection=event.target.value;
                applyTheme(selection);
                themeStorage.set(selection);
            });
        }
        if(themeSeg){
            themeSeg.addEventListener('change',event=>{
                const target=event.target;
                if(target&&target.name==='themeSegment'){
                    const selection=target.value;
                    applyTheme(selection);
                    themeStorage.set(selection);
                }
            });
        }
        const handleSystemThemeChange=()=>{
            const current=themeStorage.get()||'system';
            if(current==='system'){ applyTheme('system'); }
        };
        if(typeof prefersDarkScheme.addEventListener==='function'){
            prefersDarkScheme.addEventListener('change', handleSystemThemeChange);
        }else if(typeof prefersDarkScheme.addListener==='function'){
            prefersDarkScheme.addListener(handleSystemThemeChange);
        }

        function getLatex(){ return ta.value; }

        /* ---------- LaTeX -> Word Equation conversion ---------- */
        function toWordEquation(latex) {
            let w = String(latex ?? '');

            // Arrow variants
            w = w.replace(/\\xrightarrow\{([^}]*)\}/g, '\\buildrel $1 \\over \\longlongrightarrow');
            w = w.replace(/\\implies/g, '\\Longrightarrow');

            // Spacing and differential clean-up
            w = w.replace(/\\:/g, ' ');
            w = w.replace(/\\differentialD\s?/g, 'd');
            w = w.replace(/d\\theta/g, 'd{\\theta}');
            w = w.replace(/d\\mu/g, 'd{\\mu}');

            // Absolute value and matrix shaping for Word
            w = w.replace(/\\lvert([\s\S]*?)\\rvert/g, '\\left|$1\\right|');
            w = w.replace(/\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g, (match, inside) => {
                const content = inside.trim().replace(/\\*$/, '') + '\\\\';
                return '\\left(\\begin{matrix}' + content + '\\end{matrix}\\right)';
            });

            // Vector notation: underset tilde -> below tilde
            w = w.replace(
                /\\operatorname\{proj\}_\{\\underset\{\\sim\}\{([^}]*)\}\}\s*\\underset\{\\sim\}\{([^}]*)\}/g,
                (match, u, v) => `proj_{${u}\\below\\sim}  ${v}\\below\\sim`
            );
            w = w.replace(/\\underset\{\\sim\}\{([^}]+)\}/g, '$1\\below\\sim');
            w = w.replace(/\\underset\{([^}]+)\}\{([^}]+)\}/g, '$2\\below$1');
            w = w.replace(/\\overrightarrow\s*\{([^}]*)\}/g, '\\vec{$1}');
            w = w.replace(/\\overrightarrow\s*([A-Za-z]+)/g, (match, token) => `\\vec{${token}}`);

            // Generic projection operator fallbacks to Roman text with spacing
            w = w.replace(/\\operatorname\{proj\}_\{([^}]*)\}\\s*([A-Za-z])/g, '{\\rm proj}_$1\\ $2');
            w = w.replace(/\\operatorname\{proj\}\\s*_\{([^}]*)\}\\s*([A-Za-z])/g, '{\\rm proj}_$1\\ $2');
            w = w.replace(/\\operatorname\{proj\}_([A-Za-z])\\s*([A-Za-z])/g, '{\\rm proj}_$1\\ $2');
            w = w.replace(/\\operatorname\{proj\}_\{([^}]*)\}\\s*(?=\\)/g, '{\\rm proj}_$1\\ ');
            w = w.replace(/\\operatorname\{proj\}\\s*_\{([^}]*)\}\\s*(?=\\)/g, '{\\rm proj}_$1\\ ');

            // Remaining operatorname ‚Üí roman text
            w = w.replace(/\\operatorname\{([^}]+)\}/g, '{\\rm $1}');

            return w;
        }
        
        // Replace MathLive placeholders with visible boxes for MathJax preview
        function latexForPreview(latex){
            try{
                const src = String(latex ?? '');
                // Replace \placeholder{...} (usually empty) with a boxed space
                // Using two medium spaces to create a reasonably sized box
                const boxedGap = String.raw`\\boxed{\\;\\;}`;
                return src.replace(/\\placeholder\{[^}]*\}/g, boxedGap);
            }catch(e){ return String(latex ?? ''); }
        }
        
        function syncFromMathLive() {
            const rawLatex = mf2.getValue('latex');
            const cleanLatex = rawLatex.replace(/\\differentialD\s?/g, 'd');
            if (ta.value !== cleanLatex) { ta.value = cleanLatex; }
            wordOut.value = toWordEquation(cleanLatex);
            preview.innerHTML = '$$' + latexForPreview(cleanLatex) + '$$';
            mjxTypeset(preview);
        }

        function syncFromTextArea() {
            const cleanLatex = ta.value;
            if (mf2.getValue() !== cleanLatex) { mf2.setValue(cleanLatex); }
            wordOut.value = toWordEquation(cleanLatex);
            preview.innerHTML = '$$' + latexForPreview(cleanLatex) + '$$';
            mjxTypeset(preview);
        }
        
        function render(){ syncFromMathLive(); }

        function insertLatex(x){
            try{
                if(mf2.executeCommand){ mf2.executeCommand('insert', x); }
                else if(mf2.insert){ mf2.insert(x); }
                else { mf2.value = (mf2.value||'') + x; }
            }catch(e){}
            syncFromMathLive();
            try{ mf2.focus(); }catch(e){}
        }
        
        mf2.addEventListener('input', syncFromMathLive);
        ta.addEventListener('input', syncFromTextArea);

        /* ---------- Cleanup: delete object when all boxes emptied ---------- */
        function normalizeLatexStr(L) {
            try {
                const EMPTY_SLOT = String.raw`\s*(?:\\placeholder\{\})?\s*`;
                const EMPTY_BRACE = String.raw`\{${EMPTY_SLOT}\}`;
                L = L.replace(new RegExp(String.raw`\\frac${EMPTY_BRACE}${EMPTY_BRACE}`, "g"), "");
                L = L.replace(new RegExp(String.raw`\\sqrt${EMPTY_BRACE}`, "g"), "");
                L = L.replace(new RegExp(String.raw`\\sqrt\[${EMPTY_SLOT}\]${EMPTY_BRACE}`, "g"), "");
                L = L.replace(new RegExp(String.raw`\\(dot|ddot)${EMPTY_BRACE}`, "g"), "");
                const rm = (open, close) => new RegExp(String.raw`\\left\s*${open}${EMPTY_SLOT}\\right\s*${close}`, 'g');
                L = L.replace(rm('\\(', '\\)'), "");
                L = L.replace(rm('\\[', '\\]'), "");
                L = L.replace(rm('\\{', '\\\\}'), "");
                L = L.replace(rm('\\|', '\\|'), "");
                L = L.replace(new RegExp(String.raw`\\int_${EMPTY_BRACE}\^${EMPTY_BRACE}${EMPTY_SLOT}(?:d[a-zA-Z]+)?`, "g"), "");
                L = L.replace(new RegExp(String.raw`\\(sum|prod)_${EMPTY_BRACE}\^${EMPTY_BRACE}${EMPTY_SLOT}`, "g"), "");
                L = L.replace(new RegExp(String.raw`\\(sum|prod)_\{n=${EMPTY_SLOT}\}\^${EMPTY_BRACE}${EMPTY_SLOT}`, "g"), "");
                L = L.replace(new RegExp(String.raw`\\int\s*${EMPTY_SLOT}(?:d[a-zA-Z]+)?(?![_^])`, "g"), "");
                L = L.replace(new RegExp(String.raw`\\lim_\{x\\to\s*${EMPTY_SLOT}\}${EMPTY_SLOT}`, "g"), "");
                L = L.replace(new RegExp(String.raw`\\lim_${EMPTY_BRACE}${EMPTY_SLOT}`, "g"), "");
                L = L.replace(new RegExp(String.raw`\\begin\{pmatrix\}(?:${EMPTY_SLOT}|&|\\\\|\s)*\\end\{pmatrix\}`, "g"), '');
            } catch (e) {
                console.warn('normalizeLatexStr normalization failed', e);
            }
            return L;
        }

        function cleanupEmptyStructures(){ try{ const b=mf2.getValue('latex')||'',a=normalizeLatexStr(b); if(a!==b){ mf2.setValue(a); syncFromMathLive(); } }catch(e){console.warn('cleanup failed',e)} }
        
        function configureMathLive() {
            if (!window.MathfieldElement || !mf2) return;
            mf2.setOptions({
                mathModeSpace: '\\:',
                removeExtraneousParentheses: true,
                virtualKeyboardMode: 'manual',
                virtualKeyboards: '',
                virtualKeyboardToggleEnabled: true,
                inlineShortcutToolbar: false,
                menus: []
            });

            let isArmedForDeletion = false; // Tracks "armed" state for double-tap deletion

            // Reset armed state on non-deletion actions
            mf2.addEventListener('keydown', (ev) => {
                if (ev.key !== 'Backspace') {
                    isArmedForDeletion = false;
                }
            });

            mf2.addEventListener('input', (ev) => {
                if (ev.inputType !== 'deleteContentBackward' && ev.inputType !== 'deleteContentForward') {
                    isArmedForDeletion = false;
                }
            });

            mf2.addEventListener('focus', () => { isArmedForDeletion = false; });
            mf2.addEventListener('blur', () => {
                cleanupEmptyStructures();
                isArmedForDeletion = false;
            });
            mf2.addEventListener('move-out', () => {
                cleanupEmptyStructures();
                isArmedForDeletion = false;
            });

            // Custom Backspace handling inspired by Word for Mac Equation Editor
            mf2.addEventListener('keydown', (ev) => {
                if (ev.key !== 'Backspace') return;

                const sel = mf2.selection;
                if (!sel.isCollapsed) {
                    // Let MathLive handle normal deletion
                    isArmedForDeletion = false;
                    // Defer sync; MathLive will emit input event
                    return;
                }

                const position = sel.start;
                // Get atom at current position (assuming MathLive model access)
                const atom = mf2.model.at(position - 1); // Atom before cursor
                if (!atom) {
                    // Let MathLive handle normal deletion
                    return;
                }

                // Check if cursor is at the start of an empty placeholder/box
                const isEmptyBox = atom.type === 'placeholder' && position === atom.range.end;

                if (!isEmptyBox) {
                    // Normal deletion
                    mf2.executeCommand('deleteBackward');
                    isArmedForDeletion = false;
                    syncFromMathLive();
                    return;
                }

                // Determine if this is the "first" box in the symbol (e.g., numerator in fraction)
                const path = mf2.model.path || mf2.model.getPath(position);
                const branch = path[path.length - 1];
                const siblings = branch.parent[branch.branch] || [];
                const boxIndex = siblings.indexOf(atom);
                const isFirstBox = boxIndex === 0;

                if (!isFirstBox) {
                    // Navigate to previous box (like Word: Backspace moves to prior placeholder)
                    mf2.executeCommand('moveToPrevious');
                    isArmedForDeletion = false;
                    // Defer sync to input event
                    return;
                }

                // In first empty box: double-tap logic
                if (isArmedForDeletion) {
                    // Second tap: delete the entire symbol/structure
                    mf2.executeCommand('moveToGroupStart');
                    mf2.executeCommand('extendToGroupEnd');
                    mf2.executeCommand('delete');
                    isArmedForDeletion = false;
                } else {
                    // First tap: arm for deletion, appears to do nothing (cursor stays)
                    isArmedForDeletion = true;
                }

                // Defer sync to input event or selection change
            });

            // Typing behavior: allow free typing like Desmos (no auto-termination interception)

            // Protect navigation into fixed subscripts like \underset{\sim}{} (only main box editable)
            mf2.addEventListener('keydown', (ev) => {
                if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(ev.key)) return;

                const position = mf2.position;
                const path = mf2.model.getPath(position);
                if (path.length < 2) return;

                const parent = path[path.length - 2];
                const branch = path[path.length - 1].branch;

                let isProtected = false;
                if (parent.type === 'underset' && parent.subscript?.length > 0) {
                    const subAtom = parent.subscript[0];
                    isProtected = subAtom.command === 'sim' || subAtom.value === '~';
                }

                if (isProtected) {
                    ev.preventDefault(); // Block entry into subscript
                    if (ev.key === 'ArrowDown' || (ev.key === 'ArrowRight' && position === parent.body[parent.body.length - 1].range.end)) {
                        // Skip over subscript, move to next element after structure
                        mf2.executeCommand('moveToNext');
                    } else if (ev.key === 'ArrowUp' || (ev.key === 'ArrowLeft' && position === parent.subscript[0].range.start)) {
                        // Skip back to before structure
                        mf2.executeCommand('moveToPrevious');
                    }
                }
            });

            // Redirect selection if it lands in protected subscript
            mf2.addEventListener('selection-did-change', () => {
                try {
                    const sel = mf2.selection;
                    if (!sel.isCollapsed) return;
                    const position = sel.start;
                    const path = mf2.model.getPath(position);
                    if (path.length < 2) return;
                    const parent = path[path.length - 2];
                    const branch = path[path.length - 1].branch;
                    if (parent.type === 'underset' && branch === 'subscript' && parent.subscript?.length > 0) {
                        const subAtom = parent.subscript[0];
                        if (subAtom.command === 'sim' || subAtom.value === '~') {
                            // Redirect to end of main body
                            mf2.position = parent.body[parent.body.length - 1].range.end;
                        }
                    }
                } catch (e) {
                    console.warn('Selection change handler error:', e);
                }
            });

            // Handle deletion of atomic structures like vectors
            function tryDeleteAtomicObject(direction = 'back') {
                try {
                    const S = '\uE000'; // Sentinel
                    mf2.executeCommand('insert', S);
                    const withSentinel = mf2.getValue('latex') || '';
                    mf2.executeCommand('undo');

                    const idx = withSentinel.indexOf(S);
                    if (idx === -1) return false;

                    const left = withSentinel.slice(0, idx);
                    const right = withSentinel.slice(idx + S.length);

                    const atomicPatternEnd = /\\underset\{\\sim\}\{[a-zA-Z]\}$/;
                    const atomicPatternStart = /^\\underset\{\\sim\}\{[a-zA-Z]\}/;

                    if (direction === 'back') {
                        const match = left.match(atomicPatternEnd);
                        if (match) {
                            mf2.setValue(left.slice(0, -match[0].length) + right);
                            return true;
                        }
                    } else if (direction === 'fwd') {
                        const match = right.match(atomicPatternStart);
                        if (match) {
                            mf2.setValue(left + right.slice(match[0].length));
                            return true;
                        }
                    }
                    return false;
                } catch (e) {
                    console.warn('Atomic deletion failed:', e);
                    return false;
                }
            }

            mf2.addEventListener('beforeinput', (ev) => {
                if (ev.inputType === 'deleteContentBackward' || ev.inputType === 'deleteContentForward') {
                    if (tryDeleteAtomicObject(ev.inputType === 'deleteContentBackward' ? 'back' : 'fwd')) {
                        ev.preventDefault();
                        syncFromMathLive();
                    }
                }
            });
        }
        
        /* ---------------- Toolbar and Tabs ---------------- */
        const tabs=[{id:'calc',label:'Calculus'},{id:'func',label:'Functions'},{id:'sym',label:'Symbols'},{id:'vec',label:'Vectors'},{id:'greek',label:'Greek'},{id:'complex',label:'Complex'},{id:'sets',label:'Sets'}];
        const tabRowConfig={};
        const allLetters=Array.from('abcdefghijklmnopqrstuvwxyz');
        function vectorKey(b,d,c){const a=c?c.concat(allLetters.filter(e=>!c.includes(e))):allLetters.slice();return{base:b,currentVar:d,insert:`${b}{${d}}`,display:`${b}{${d}}`,options:a,isSelectable:!0}}
        
        const layouts={
            calc:[
                {display:'\\int_{\\placeholder{}}^{\\placeholder{}} \\placeholder{}\\;dx',insert:'\\int_{\\placeholder{}}^{\\placeholder{}} \\placeholder{} dx'},
                {display:'\\int \\placeholder{}\\;dx', insert:'\\int \\placeholder{} dx'},
                {display:'\\left.\\placeholder{}\\right|_{\\placeholder{}}^{\\placeholder{}}',insert:'\\left.\\placeholder{}\\right|_{\\placeholder{}}^{\\placeholder{}}'},
                {display:'\\sum_{n=\\placeholder{}}^{\\placeholder{}} \\placeholder{}',insert:'\\sum_{n=\\placeholder{}}^{\\placeholder{}} \\placeholder{}'},
                {display:'\\prod_{n=\\placeholder{}}^{\\placeholder{}} \\placeholder{}',insert:'\\prod_{n=\\placeholder{}}^{\\placeholder{}} \\placeholder{}'},
                {display:'\\lim_{x\\to\\placeholder{}} \\placeholder{}',insert:'\\lim_{x\\to\\placeholder{}} \\placeholder{}'},
                {display:'\\frac{d}{dx}(\\placeholder{})',insert:'\\frac{d}{dx}\\left(\\placeholder{}\\right)'}
            ],
            func:[{display:'\\sin(\\placeholder{})',insert:'\\sin(\\placeholder{})'},{display:'\\cos(\\placeholder{})',insert:'\\cos(\\placeholder{})'},{display:'\\tan(\\placeholder{})',insert:'\\tan(\\placeholder{})'},{display:'\\sin^{-1}(\\placeholder{})',insert:'\\sin^{-1}(\\placeholder{})'},{display:'\\cos^{-1}(\\placeholder{})',insert:'\\cos^{-1}(\\placeholder{})'},{display:'\\tan^{-1}(\\placeholder{})',insert:'\\tan^{-1}(\\placeholder{})'},{display:'\\ln(\\placeholder{})',insert:'\\ln(\\placeholder{})'},{display:'\\log_{\\placeholder{}}(\\placeholder{})',insert:'\\log_{\\placeholder{}}(\\placeholder{})'},{display:'e^{\\placeholder{}}',insert:'e^{\\placeholder{}}'},{display:'\\lvert \\placeholder{} \\rvert',insert:'\\lvert \\placeholder{} \\rvert'},{display:'\\sqrt{\\placeholder{}}',insert:'\\sqrt{\\placeholder{}}', hint: 'root'},{display:'\\sqrt[\\placeholder{}]{\\placeholder{}}',insert:'\\sqrt[\\placeholder{}]{\\placeholder{}}', hint: 'root'}],
            sym:[
                {display:'\\geq',insert:'\\geq'},
                {display:'\\leq',insert:'\\leq'},
                {display:'\\pm', insert:'\\pm'},
                {display:'\\angle', insert: '\\angle'},
                {display:'^{\\circ}', insert:'^{\\circ}',hint:'circ'},
                {display:'\\neg',insert:'\\neg'},
                {display:'\\exists',insert:'\\exists'},
                {display:'\\forall',insert:'\\forall'},
                {display:'\\infty',insert:'\\infty'},
                {display:'\\neq',insert:'\\neq'},
                {display:'\\approx',insert:'\\approx'},
                {display:'\\equiv',insert:'\\equiv'},
                {display:'\\to',insert:'\\to'},
                {display:'\\implies',insert:'\\implies'},
                {display:'\\iff',insert:'\\iff'},
                {display:'\\sim',insert:'\\sim'}
            ],

            vec:[
                vectorKey('\\vec','v',['v','u','w','r','a']),
                vectorKey('\\dot','x',['x','y','z','r','v']),
                vectorKey('\\ddot','x',['x','y','z','r','a']),
                {display:'\\operatorname{proj}_{\\underset{\\sim}{\\placeholder{}}}\\underset{\\sim}{\\placeholder{}}',insert:'\\operatorname{proj}_{\\underset{\\sim}{\\placeholder{}}}\\underset{\\sim}{\\placeholder{}}'},
                {
                    isSelectable: true,
                    base: '\\underset{\\sim}',
                    currentVar: '\\placeholder{}',
                    insert: '\\underset{\\sim}{\\placeholder{}}',
                    display: '\\underset{\\sim}{\\placeholder{}}',
                    options: [
                        { value: '\\placeholder{}', text: '‚ñ°' },
                        'a','b','c','u','v','w','r',
                        ...allLetters.filter(l => !['a','b','c','u','v','w','r'].includes(l))
                    ]
                },
                {display:'\\underset{\\sim}{i}',insert:'\\underset{\\sim}{i}'},
                {display:'\\underset{\\sim}{j}',insert:'\\underset{\\sim}{j}'},
                {display:'\\underset{\\sim}{k}',insert:'\\underset{\\sim}{k}'},
                {display:'\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}',insert:'\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}'},
                {display:'\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}',insert:'\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}'},
                {display:'\\overrightarrow{\\placeholder{}}',insert:'\\overrightarrow{\\placeholder{}}'}
            ],
            greek:[{display:'\\alpha',insert:'\\alpha'},{display:'\\beta',insert:'\\beta'},{display:'\\gamma',insert:'\\gamma'},{display:'\\delta',insert:'\\delta'},{display:'\\theta',insert:'\\theta'},{display:'\\lambda',insert:'\\lambda'},{display:'\\mu',insert:'\\mu'},{display:'\\sigma',insert:'\\sigma'},{display:'\\omega',insert:'\\omega'},{display:'\\Delta',insert:'\\Delta'}],
            complex:[
                {
                    isSelectable: true,
                    keyType: 'cis',
                    currentVar: '\\theta',
                    display: '\\operatorname{cis}(\\theta)',
                    insert: '\\cos(\\theta)+i\\sin(\\theta)',
                    options: ['\\theta', '\\alpha', '\\beta', '\\gamma']
                },
                {
                    isSelectable: true,
                    keyType: 'cos-isin',
                    currentVar: '\\theta',
                    display: '\\cos(\\theta)+i\\sin(\\theta)',
                    insert: '\\cos(\\theta)+i\\sin(\\theta)',
                    options: ['\\theta', '\\alpha', '\\beta', '\\gamma']
                },
                {display:'|z|',insert:'|z|'},
                {display:'arg(z)',insert:'arg(z)'},
                {display:'\\overline{z}',insert:'\\overline{z}'},
                {display:'Re(z)',insert:'Re(z)'},
                {display:'Im(z)',insert:'Im(z)'}
                
            ],
            sets:[{display:'\\in',insert:'\\in'},{display:'\\mathbb{Z}',insert:'\\mathbb{Z}'},{display:'\\mathbb{Z}^+',insert:'\\mathbb{Z}^+'},{display:'\\mathbb{N}',insert:'\\mathbb{N}'},{display:'\\mathbb{Q}',insert:'\\mathbb{Q}'},{display:'\\mathbb{R}',insert:'\\mathbb{R}'},{display:'\\mathbb{C}',insert:'\\mathbb{C}'}]
        };

        // Curated layouts for toolbar
        const curatedLayouts = {
            calc: [
                { display: '\\int \\placeholder{}\\;dx', insert: '\\int \\placeholder{} dx' },
                { display: '\\int_{\\placeholder{}}^{\\placeholder{}} \\placeholder{}\\;dx', insert: '\\int_{\\placeholder{}}^{\\placeholder{}} \\\nplaceholder{} dx' },
                { display: '\\left.\\placeholder{}\\right|_{\\placeholder{}}^{\\placeholder{}}', insert: '\\left.\\placeholder{}\\right|_{\\placeholder{}}^{\\placeholder{}}' }
            ],
            func: [
                { display: '\\sqrt{\\placeholder{}}', insert: '\\sqrt{\\placeholder{}}' },
                { display: '\\sqrt[\\placeholder{}]{\\placeholder{}}', insert: '\\sqrt[\\placeholder{}]{\\placeholder{}}' }
            ],
            sym: [
                { display: '\\geq', insert: '\\geq' },
                { display: '\\leq', insert: '\\leq' },
                { display: '~', insert: '~', renderMode: 'text' },
                { display: '^{\\circ}', insert:'^{\\circ}', hint: 'circ' },
                { display: '\\neg', insert: '\\neg' },
                { display: '\\exists', insert: '\\exists' },
                { display: '\\forall', insert: '\\forall' },
                { display: '\\infty', insert: '\\infty' }
            ],
            vec: [
                {
                    isSelectable: true,
                    base: '\\underset{\\sim}',
                    currentVar: '\\placeholder{}',
                    insert: '\\underset{\\sim}{\\placeholder{}}',
                    display: '\\underset{\\sim}{\\placeholder{}}',
                    options: [
                        { value: '\\placeholder{}', text: '‚ñ°' },
                        'a','b','c','u','v','w','r'
                    ].concat(allLetters.filter(l => !['a','b','c','u','v','w','r'].includes(l)))
                },
                { display: '\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}', insert: '\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}' },
                { display: '\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}', insert: '\\begin{pmatrix} \\placeholder{} \\\\ \\placeholder{} \\\\ \\placeholder{} \\end{pmatrix}' },
                { display: '\\overrightarrow{\\placeholder{}}', insert: '\\overrightarrow{\\placeholder{}}' }
            ],
            greek: [
                { display: '\\alpha', insert: '\\alpha' },
                { display: '\\beta', insert: '\\beta' },
                { display: '\\gamma', insert: '\\gamma' },
                { display: '\\theta', insert: '\\theta' },
                { display: '\\lambda', insert: '\\lambda' },
                { display: '\\mu', insert: '\\mu' },
                { display: '\\sigma', insert: '\\sigma' }
            ],
            complex: [
                {
                    isSelectable: true,
                    keyType: 'cos-isin',
                    currentVar: '\\theta',
                    display: '\\cos(\\theta)+i\\sin(\\theta)',
                    insert: '\\cos(\\theta)+i\\sin(\\theta)',
                    options: ['\\theta', '\\alpha', '\\beta', '\\gamma']
                },
                { display: '|z|', insert: '|z|' },
                { display: 'arg(z)', insert: 'arg(z)' },
                { display: '\\overline{z}', insert: '\\overline{z}' }
            ],
            sets: [
                { display: '\\in', insert: '\\in' },
                { display: '\\mathbb{N}', insert: '\\mathbb{N}' },
                { display: '\\mathbb{Z}', insert: '\\mathbb{Z}' },
                { display: '\\mathbb{Q}', insert: '\\mathbb{Q}' },
                { display: '\\mathbb{R}', insert: '\\mathbb{R}' }
            ]
        };


        function buildTabs(){
            const tabsContainer=document.getElementById('tabs');
            tabsContainer.innerHTML='';
            tabs.forEach(tabInfo=>{
                const tabEl=document.createElement('button');
                tabEl.type='button';
                tabEl.className='tab';
                tabEl.textContent=tabInfo.label;
                tabEl.dataset.tabId=tabInfo.id;
                const activateTab = () => {
                    pinnedTabId = tabInfo.id;
                    toggleExpand(tabInfo.id);
                };

                tabEl.addEventListener('click', activateTab);
                tabEl.addEventListener('mouseenter', activateTab);
                
                tabsContainer.appendChild(tabEl);
            });
            const tabEls=Array.from(tabsContainer.querySelectorAll('.tab'));
            tabEls.forEach((tabEl,index)=>{
                tabEl.addEventListener('keydown',(event)=>handleTabKeyNavigation(event,index,tabEls));
            });
            
            // Add mouseleave functionality to hide expanded list when cursor moves away from the entire hover area
            const expArea = document.getElementById('expanded-area');
            
            // Create a single hover area that includes both tabs and expanded area
            const hoverArea = document.createElement('div');
            hoverArea.className = 'hover-area';
            hoverArea.style.position = 'relative';
            hoverArea.style.display = 'block';
            hoverArea.style.width = '100%';
            
            // Move tabs container and expanded area into the hover area
            const parent = tabsContainer.parentNode;
            parent.insertBefore(hoverArea, tabsContainer);
            hoverArea.appendChild(tabsContainer);
            hoverArea.appendChild(expArea);
            hoverArea.addEventListener('mouseleave', () => {
                if (pinnedTabId) {
                    toggleExpand(pinnedTabId);
                }
            });

            syncTabHighlight();
        }

        function handleTabKeyNavigation(event,currentIndex,tabEls){
            const { key } = event;
            if(['ArrowLeft','ArrowUp','ArrowRight','ArrowDown'].includes(key)){
                event.preventDefault();
                const direction = (key==='ArrowLeft'||key==='ArrowUp') ? -1 : 1;
                const nextIndex = (currentIndex + direction + tabEls.length) % tabEls.length;
                tabEls[nextIndex].focus();
                return;
            }
            if(key===' ' || key==='Enter'){
                event.preventDefault();
                tabEls[currentIndex].click();
            }
        }

        function renderMathInPlace(element){
            if(!element || !element.dataset) return;
            const latex = element.dataset.math;
            if(!latex) return;

            const renderMode = element.dataset.renderMode || 'math';
            if(renderMode === 'text'){
                element.textContent = latex;
                element.classList.add('math-display-text');
                return;
            }

            element.classList.remove('math-display-text');

            let latexForRender = latex;
            if(latex.includes('\\placeholder')){
                // Fix stubborn boxes: keep placeholders inside \underset{\sim}{...} at text size
                latexForRender = latexForRender.replace(/\\underset\\{\\sim\\}\\{\\placeholder\\{\\}\\}/g, '\\underset{\\sim}{\\square}');
                // Force remaining placeholders to a constant size regardless of script level
                latexForRender = latexForRender.replace(/\\placeholder\{\}/g, '{\\displaystyle\\square}');
            }

            if (window.MathJax && window.MathJax.tex2svgPromise) {
                window.MathJax.tex2svgPromise(latexForRender).then(node => {
                    const svg = node.querySelector('svg');
                    if (svg) {
                        element.innerHTML = '';
                        const wrapper = document.createElement('span');
                        wrapper.className = 'math-render';
                        wrapper.appendChild(svg);
                        element.appendChild(wrapper);
                    }
                }).catch(err => console.warn('MathJax tex2svg failed:', err));
            } else {
                element.textContent = latex;
                element.classList.add('math-display-text');
            }
        }

        function latexTokenToUnicode(token){
            const map = new Map([
                ['\\alpha','Œ±'],['\\beta','Œ≤'],['\\gamma','Œ≥'],['\\delta','Œ¥'],['\\epsilon','Œµ'],['\\zeta','Œ∂'],['\\eta','Œ∑'],['\\theta','Œ∏'],['\\iota','Œπ'],['\\kappa','Œ∫'],['\\lambda','Œª'],['\\mu','Œº'],['\\nu','ŒΩ'],['\\xi','Œæ'],['\\omicron','Œø'],['\\pi','œÄ'],['\\rho','œÅ'],['\\sigma','œÉ'],['\\tau','œÑ'],['\\upsilon','œÖ'],['\\phi','œÜ'],['\\chi','œá'],['\\psi','œà'],['\\omega','œâ'],
                ['\\Gamma','Œì'],['\\Delta','Œî'],['\\Theta','Œò'],['\\Lambda','Œõ'],['\\Xi','Œû'],['\\Pi','Œ†'],['\\Sigma','Œ£'],['\\Upsilon','Œ•'],['\\Phi','Œ¶'],['\\Psi','Œ®'],['\\Omega','Œ©']
            ]);
            if(token==='\\placeholder{}') return '‚ñ°';
            return map.get(token) || token;
        }

        function formatSelectOptionLabel(value, providedText){
            if(typeof providedText==='string' && providedText.trim().length>0){
                return providedText;
            }
            if(typeof value==='string'){
                return latexTokenToUnicode(value);
            }
            return String(value);
        }

        function createKeyElement(d){
            if(d.isSelectable){
                const key=document.createElement('button');
                key.type='button';
                key.className='key has-selector';
                key.tabIndex=-1;

                const mathContent=document.createElement('div');
                mathContent.className='math-display';
                mathContent.dataset.math=d.display;
                // Always render with MathJax unless explicitly requested as text
                mathContent.dataset.renderMode = d.renderMode || 'math';
                const selector=document.createElement('select');
                selector.className='selector';

                d.options.forEach(opt=>{
                    const optionEl=document.createElement('option');
                    let val, txt;
                    if(typeof opt==='object' && opt.value!==undefined){
                        val = opt.value;
                        txt = opt.text;
                    } else {
                        val = opt;
                        txt = undefined;
                    }
                    optionEl.value = val;
                    optionEl.textContent = formatSelectOptionLabel(val, txt);
                    if(val === d.currentVar) optionEl.selected = true;
                    selector.appendChild(optionEl);
                });

                ['click','mousedown','touchstart'].forEach(eventType=>{
                    selector.addEventListener(eventType, event=>event.stopPropagation(), { capture:true });
                });

                selector.addEventListener('change', event=>{
                    d.currentVar=event.target.value;
                    const currentVal=d.currentVar;

                    if(d.keyType==='cis'){
                        d.insert=`\\cos(${currentVal})+i\\sin(${currentVal})`;
                        d.display=`\\operatorname{cis}(${currentVal})`;
                    }else if(d.keyType==='cos-isin'){
                        d.insert=`\\cos(${currentVal})+i\\sin(${currentVal})`;
                        d.display=d.insert;
                    }else{
                        d.insert=`${d.base}{${currentVal}}`;
                        d.display=`${d.base}{${currentVal}}`;
                    }
                    
                    mathContent.dataset.math=d.display;
                    if(d.renderMode){
                        mathContent.dataset.renderMode = d.renderMode;
                    }else{
                        mathContent.dataset.renderMode = 'math';
                    }
                renderMathInPlace(mathContent);
                try { mf2 && mf2.focus({ preventScroll: true }); setTimeout(()=>{ try{ mf2 && mf2.focus({ preventScroll: true }); }catch(_){} }, 0); } catch(_) {}
                });

                mathContent.textContent=d.display;
                key.addEventListener('click', event=>{ if(event.target!==selector) insertLatex(d.insert); });

                key.appendChild(mathContent);
                key.appendChild(selector);
                renderMathInPlace(mathContent);
                return key;
            }

            const key=document.createElement('button');
            key.type='button';
            key.className='key';
            key.tabIndex=-1;
            const mathSpan=document.createElement('span');
            mathSpan.className='math-display';
            mathSpan.dataset.math=d.display;
            if(d.renderMode){
                mathSpan.dataset.renderMode = d.renderMode;
            }else{
                mathSpan.dataset.renderMode = 'math';
            }
            mathSpan.textContent=d.display;
            key.appendChild(mathSpan);
            key.addEventListener('click',()=>insertLatex(d.insert));
            renderMathInPlace(mathSpan);
            return key;
        }


        let currentExpandedTab = null;
        let pinnedTabId = null;
        function syncTabHighlight(){
            document.querySelectorAll('#tabs .tab').forEach(tabEl=>{
                const tabId=tabEl.dataset.tabId;
                const isExpanded=currentExpandedTab===tabId;
                tabEl.setAttribute('data-expanded', isExpanded ? 'true' : 'false');
            });
        }
        function toggleExpand(id) {
            const expArea = document.getElementById('expanded-area');
            if (!expArea) return;
            if (currentExpandedTab === id && expArea.childElementCount) {
                return;
            }

            expArea.innerHTML = '';
            expArea.setAttribute('data-tab-id', id);
            const layoutItems = layouts[id] ?? [];
            const rowCount = tabRowConfig[id] || 1;
            const perRow = Math.max(1, Math.ceil(layoutItems.length / rowCount) || layoutItems.length || 1);

            // Add keys directly to expanded area for horizontal grid layout
            layoutItems.forEach((item, itemIndex) => {
                const keyEl = createKeyElement(item);
                expArea.appendChild(keyEl);
            });
            const columnCount = Math.max(layoutItems.length, 1);
            expArea.style.setProperty('--expanded-columns', columnCount);
            currentExpandedTab = id;
            syncTabHighlight();
            
            // Typeset the newly created buttons with proper timing
            setTimeout(() => {
                typesetMathElements();
            }, 100);
            
            // Additional typeset after a longer delay to ensure MathJax is ready
            setTimeout(() => {
                typesetMathElements();
            }, 500);

            // Ensure math field remains active after interacting with tabs
            try { mf2 && mf2.focus({ preventScroll: true }); } catch(_) {}
            setTimeout(()=>{ try{ mf2 && mf2.focus({ preventScroll: true }); }catch(_){} }, 0);
        }
        
        buildTabs(); // Build tabs early
        if (tabs.length) {
            pinnedTabId = tabs[0].id;
            toggleExpand(pinnedTabId);
        }

        /* ---------------- Load MathLive ---------------- */
        async function loadMathLive(){
            const sources = {
                coreCss: ['https://unpkg.com/mathlive/dist/mathlive.core.css', 'https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.core.css'],
                css: ['https://unpkg.com/mathlive/dist/mathlive.css', 'https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.css'],
                js: ['https://unpkg.com/mathlive/dist/mathlive.min.js', 'https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.min.js']
            };
            let loaded = false;

            // Load core CSS
            for (const url of sources.coreCss) {
                try {
                    await new Promise((resolve, reject) => {
                        const link = document.createElement('link');
                        link.rel = 'stylesheet';
                        link.href = url;
                        link.onload = () => resolve();
                        link.onerror = () => reject();
                        document.head.appendChild(link);
                    });
                    loaded = true;
                    break;
                } catch (e) {
                    console.warn('Failed to load core CSS from', url, e);
                }
            }

            // Load main CSS
            for (const url of sources.css) {
                try {
                    await new Promise((resolve, reject) => {
                        const link = document.createElement('link');
                        link.rel = 'stylesheet';
                        link.href = url;
                        link.onload = () => resolve();
                        link.onerror = () => reject();
                        document.head.appendChild(link);
                    });
                    break;
                } catch (e) {
                    console.warn('Failed to load CSS from', url, e);
                }
            }

            // Load JavaScript
            for (const url of sources.js) {
                try {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = url;
                        script.defer = true;
                        script.onload = () => resolve();
                        script.onerror = () => reject();
                        document.head.appendChild(script);
                    });
                    status.textContent = 'MathLive loaded';
                    loaded = true;
                    break;
                } catch (e) {
                    console.warn('Failed to load MathLive JS from', url, e);
                }
            }

            if (!loaded) {
                console.warn('MathLive failed to load from all sources');
                status.textContent = 'MathLive unavailable';
            }

            return loaded;
        }

        async function waitForMathFieldDefinition(){
            try{
                if(window.customElements && typeof customElements.whenDefined==='function'){
                    await customElements.whenDefined('math-field');
                }
            }catch(e){ console.warn('math-field definition wait failed', e); }
        }

        function typesetMathElements(){
            const mathElements=document.querySelectorAll('.math-display');
            mathElements.forEach(renderMathInPlace);
        }

        (async()=>{
            const loaded=await loadMathLive();
            await waitForMathFieldDefinition();
            
            // Wait for MathJax to be ready
            if (window.MathJax && window.MathJax.startup) {
                await window.MathJax.startup.promise;
            }
            
            // Initial typeset of any existing elements
            typesetMathElements();
            
            if(loaded && window.MathfieldElement){
                configureMathLive();
                status.textContent='Ready';
                try{ mf2 && mf2.focus({ preventScroll: true }); }catch(_){}
            }else{
                status.textContent='Fallback mode - MathLive not available';
            }
            
            // Ensure buttons are properly typeset after a short delay
            setTimeout(() => {
                typesetMathElements();
            }, 500);
            
            // Additional typeset after MathJax is fully ready
            setTimeout(() => {
                typesetMathElements();
            }, 1000);
        })();

        function showToast(msg = 'Copied!') {
          const toast = document.getElementById('toast');
          if (!toast) return;
          toast.textContent = msg;
          toast.classList.add('show');
          clearTimeout(showToast._t);
          showToast._t = setTimeout(() => toast.classList.remove('show'), 1600);
        }

        /* ---------------- Copy buttons ---------------- */
        async function copyToClipboard(a, b) {
          const label = b || 'text';
          let ok = false;
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(a);
              ok = true;
            }
          } catch (c) {
            // fall through to legacy path
          }
          if (!ok) {
            const d = document.createElement('textarea');
            d.value = a;
            d.setAttribute('readonly', '');
            d.style.position = 'fixed';
            d.style.left = '-9999px';
            document.body.appendChild(d);
            d.select();
            try {
              document.execCommand('copy');
              ok = true;
            } catch (c) {
              ok = false;
            } finally {
              document.body.removeChild(d);
            }
          }

          status.textContent = ok ? `Copied ${label} ‚úì` : `Copy ${label} failed`;
          showToast(ok ? `Copied ${label} ‚úì` : 'Copy failed');
        }
        document.getElementById('copyBtn').addEventListener('click',()=>copyToClipboard(getLatex()??'','LaTeX'));
        document.getElementById('copyWordBtn').addEventListener('click',()=>copyToClipboard(wordOut.value??'','Word Equation'));
        document.getElementById('headerCopyLatex').addEventListener('click',()=>copyToClipboard(getLatex()??'','LaTeX'));
        document.getElementById('headerCopyWord').addEventListener('click',()=>copyToClipboard(wordOut.value??'','Word Equation'));
    </script>
</body>
</html>
